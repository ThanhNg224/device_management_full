package com.example.testnative.service

import android.app.DownloadManager
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.database.Cursor
import android.net.Uri


import android.os.Environment
import android.util.Log
import androidx.core.content.ContextCompat
import androidx.core.content.FileProvider
import java.io.File


class ApkUpdateManager(
    private val context: Context,
    private val onResult: (Boolean) -> Unit
) {
    @Volatile private var currentTargetPackage: String? = null
    private val downloadManager = context.getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager
    private var downloadId: Long = -1
    private var apkFile: File? = null

    private val downloadReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            val id = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1)
            if (id == downloadId) {
                handleDownloadComplete()
            }
        }
    }

    fun downloadAndInstall(apkUrl: String, filename: String, namePackage: String) {
        Log.d("ApkUpdateMgr", "‚¨áÔ∏è Starting download for: $filename")
        Log.d("ApkUpdateMgr", "üîó APK URL: $apkUrl")
        Log.d("ApkUpdateMgr", "üì¶ Target package (hint from BE): $namePackage")
        Log.d("ApkUpdateMgr", "ü§ñ Controller app package: ${context.packageName}")

        // (Gi·ªØ) whitelist c·∫£nh b√°o
        val allowedTargets = listOf("com.atin.arcface", "com.sunworld.terminal")
        if (namePackage !in allowedTargets) {
            Log.w("ApkUpdateMgr", "‚ö†Ô∏è Warning: installing unlisted package $namePackage")
        }

        // Receiver anonymous ƒë·ªÉ ƒë·∫£m b·∫£o ta set currentTargetPackage ƒë√∫ng l√∫c t·∫£i xong
        val filter = IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE)
        val receiver = object : BroadcastReceiver() {
            override fun onReceive(ctx: Context?, intent: Intent?) {
                val id = intent?.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1L) ?: -1L
                if (id != downloadId) return

                try {
                    // Query tr·∫°ng th√°i t·∫£i
                    val query = DownloadManager.Query().setFilterById(downloadId)
                    val cursor = downloadManager.query(query)
                    cursor.use { c ->
                        if (c != null && c.moveToFirst()) {
                            val status = c.getInt(c.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS))
                            if (status == DownloadManager.STATUS_SUCCESSFUL) {
                                Log.d("ApkUpdateMgr", "üì• Download completed. Verifying...")

                                // File ƒë√≠ch (ƒë∆∞·ªùng d·∫´n public m√† b·∫°n ƒë√£ set)
                                apkFile = File(
                                    Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS),
                                    filename
                                )

                                if (apkFile?.exists() == true) {
                                    Log.d("ApkUpdateMgr", "‚úÖ Download successful, starting installApk()")
                                    Log.d("ApkUpdateMgr", "üì¶ installApk() called")
                                    Log.d("ApkUpdateMgr", "üìÅ APK file exists at: ${apkFile!!.absolutePath}")

                                    // >>> Quan tr·ªçng: resolve packageName th·ª±c t·ª´ file APK
                                    val realPkg = getApkPackageName(context, apkFile!!)
                                    currentTargetPackage = realPkg ?: namePackage
                                    Log.d(
                                        "ApkUpdateMgr",
                                        "üì¶ Resolved package from APK: ${realPkg ?: "N/A"} (backend hint: $namePackage)"
                                    )

                                    // G·ªçi flow c√†i hi·ªán c√≥ c·ªßa b·∫°n (gi·ªØ nguy√™n h√†m s·∫µn c√≥)
                                    installApk()  // n·∫øu b·∫°n g·ªçi tr·ª±c ti·∫øp installViaRoot(apkFile!!) c≈©ng ƒë∆∞·ª£c
                                } else {
                                    Log.e("ApkUpdateMgr", "‚ùå APK file not found after download")
                                    onResult(false)
                                }
                            } else {
                                Log.e("ApkUpdateMgr", "‚ùå Download failed with status=$status")
                                onResult(false)
                            }
                        } else {
                            Log.e("ApkUpdateMgr", "‚ùå Download query returned no rows")
                            onResult(false)
                        }
                    }
                } catch (e: Exception) {
                    Log.e("ApkUpdateMgr", "‚ùå Error handling download completion", e)
                    onResult(false)
                } finally {
                    // Lu√¥n h·ªßy ƒëƒÉng k√Ω ƒë·ªÉ tr√°nh leak
                    try { context.applicationContext.unregisterReceiver(this) } catch (_: Exception) {}
                }
            }
        }

        try {
            context.applicationContext.registerReceiver(receiver, filter)
            Log.d("ApkUpdateMgr", "‚úÖ Registered download complete receiver")
        } catch (e: Exception) {
            Log.e("ApkUpdateMgr", "‚ùå Failed to register receiver", e)
            onResult(false)
            return
        }

        // T·∫°o y√™u c·∫ßu download file APK (gi·ªØ nguy√™n)
        val request = DownloadManager.Request(Uri.parse(apkUrl)).apply {
            setTitle("Updating $namePackage")
            setDescription("Downloading APK update...")
            setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED)

            // (khuy·∫øn ngh·ªã) tr√°nh kho·∫£ng tr·∫Øng -> nh∆∞ng b·∫°n ƒë√£ quote l√∫c c√†i n√™n c√≥ th·ªÉ gi·ªØ nguy√™n
            // val safeFilename = filename.replace("\\s+".toRegex(), "_")
            // setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, safeFilename)
            // apkFile = File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS), safeFilename)

            setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, filename)
            setAllowedOverMetered(true)
            setAllowedOverRoaming(true)
        }

        downloadId = downloadManager.enqueue(request)
        apkFile = File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS), filename)

        Log.d("ApkUpdateMgr", "üì• Enqueued download with ID: $downloadId")
    }



    private fun handleDownloadComplete() {
        Log.d("ApkUpdateMgr", "üì• Download completed. Verifying...")

        val query = DownloadManager.Query().setFilterById(downloadId)
        val cursor: Cursor = downloadManager.query(query)

        if (cursor.moveToFirst()) {
            val status = cursor.getInt(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS))

            when (status) {
                DownloadManager.STATUS_SUCCESSFUL -> {
                    Log.d("ApkUpdateMgr", "‚úÖ Download successful, starting installApk()")
                    cursor.close()
                    installApk()
                }
                DownloadManager.STATUS_FAILED -> {
                    Log.e("ApkUpdateMgr", "‚ùå Download failed")
                    cursor.close()
                    cleanup()
                    onResult(false)
                }
            }
        } else {
            Log.e("ApkUpdateMgr", "‚ùå No cursor found for download ID")
            cursor.close()
            cleanup()
            onResult(false)
        }
    }


    private fun installApk() {
        Log.d("ApkUpdateMgr", "üì¶ installApk() called")
        apkFile?.let { file ->
            if (file.exists()) {
                Log.d("ApkUpdateMgr", "üìÅ APK file exists at: ${file.absolutePath}")
                if (isDeviceRooted()) {
                    Log.d("ApkUpdateMgr", "‚úÖ Device is rooted, installing via root")
                    installViaRoot(file)
                } else {
                    Log.d("ApkUpdateMgr", "‚ö†Ô∏è Not rooted, using install via intent")
                    installViaIntent(file)
                }
            } else {
                Log.e("ApkUpdateMgr", "‚ùå APK file does not exist: ${file.absolutePath}")
                cleanup()
                onResult(false)
            }
        } ?: run {
            Log.e("ApkUpdateMgr", "‚ùå apkFile is null")
            cleanup()
            onResult(false)
        }
    }


    private fun isDeviceRooted(): Boolean {
        return try {
            val process = Runtime.getRuntime().exec(arrayOf("su", "-c", "echo rooted_check"))
            val output = process.inputStream.bufferedReader().readText()
            val exitCode = process.waitFor()
            Log.d("ApkUpdateMgr", "üîç su test output: $output, exitCode=$exitCode")
            exitCode == 0
        } catch (e: Exception) {
            Log.e("ApkUpdateMgr", "‚ùå su test failed", e)
            false
        }
    }

    // helper: quote an to√†n cho shell
    private fun shellQuote(path: String): String {
        return "'" + path.replace("'", "'\\''") + "'"
    }

    private fun runSu(cmd: String): Triple<Int, String, String> {
        val p = Runtime.getRuntime().exec(arrayOf("su", "-c", cmd))
        val stdout = p.inputStream.bufferedReader().readText()
        val stderr = p.errorStream.bufferedReader().readText()
        val code = p.waitFor()
        return Triple(code, stdout, stderr)
    }

    // installViaRoot(...)
    private fun installViaRoot(file: java.io.File) {
        val tmpPath = "/data/local/tmp/${file.name}"
        val src = shellQuote(file.absolutePath)
        val dst = shellQuote(tmpPath)

        // copy + chmod
        val prepCmd = "cp -f $src $dst && chmod 644 $dst"
        Log.d("ApkUpdateMgr", "Running root prep via: su -c $prepCmd")
        val (prepCode, prepOut, prepErr) = runSu(prepCmd)
        Log.d("ApkUpdateMgr", "STDOUT (prep):\n$prepOut")
        if (prepErr.isNotBlank()) Log.e("ApkUpdateMgr", "‚ö†STDERR (prep):\n$prepErr")
        if (prepCode != 0) {
            cleanupTmp(dst); cleanup(); onResult(false); return
        }

        // c√†i l·∫ßn 1 (update th∆∞·ªùng)
        var installCmd = "pm install -r -g --user 0 $dst"
        var (code, out, err) = runSu(installCmd)
        Log.d("ApkUpdateMgr", "STDOUT:\n$out")
        if (err.isNotBlank()) Log.e("ApkUpdateMgr", "‚ö†STDERR:\n$err")
        Log.d("ApkUpdateMgr", "Exit code: $code")

        val normalized = (out + "\n" + err).lowercase()

        // case: downgrade
        if (code != 0 && normalized.contains("version_downgrade")) {
            Log.w("ApkUpdateMgr", "Detected VERSION_DOWNGRADE ‚Üí retry with -d")
            val (code2, out2, err2) = runSu("pm install -r -d -g --user 0 $dst")
            Log.d("ApkUpdateMgr", "STDOUT (retry -d):\n$out2")
            if (err2.isNotBlank()) Log.e("ApkUpdateMgr", "‚ö†STDERR (retry -d):\n$err2")
            code = code2
        }

        // case: signature mismatch ‚Üí uninstall r·ªìi c√†i m·ªõi (m·∫•t data)
        if (code != 0 && normalized.contains("update_incompatible")) {
            val pkg = currentTargetPackage
            if (!pkg.isNullOrBlank()) {
                Log.w("ApkUpdateMgr", "Detected UPDATE_INCOMPATIBLE ‚Üí uninstall $pkg then reinstall")
                val (uCode, uOut, uErr) = runSu("pm uninstall --user 0 ${shellQuote(pkg)}")
                Log.d("ApkUpdateMgr", "STDOUT (uninstall):\n$uOut")
                if (uErr.isNotBlank()) Log.e("ApkUpdateMgr", "‚ö†STDERR (uninstall):\n$uErr")
                val (code3, out3, err3) = runSu("pm install -g --user 0 $dst")
                Log.d("ApkUpdateMgr", "STDOUT (reinstall):\n$out3")
                if (err3.isNotBlank()) Log.e("ApkUpdateMgr", "‚ö†STDERR (reinstall):\n$err3")
                code = code3
            } else {
                Log.e("ApkUpdateMgr", "No package name available to uninstall.")
            }
        }

        cleanupTmp(dst)
        cleanup()
        onResult(code == 0)
    }

   // b·∫£n installViaRoot c≈© (kh√¥ng t·ª± detect downgrade/uninstall)
//    private fun installViaRoot(file: File) {
//        val tmpPath = "/data/local/tmp/${file.name}"
//        val src = shellQuote(file.absolutePath)
//        val dst = shellQuote(tmpPath)
//
//        // -f ƒë·ªÉ ghi ƒë√® n·∫øu ƒë√£ t·ªìn t·∫°i, v√† lu√¥n lu√¥n quote c·∫£ src l·∫´n dst
//        val copyCmd = "cp -f $src $dst && chmod 644 $dst"
//        // th√™m -r (reinstall), c√≥ th·ªÉ c√¢n nh·∫Øc -d (cho ph√©p downgrade) v√† -g (t·ª± grant runtime perms)
//        val installCmd = "pm install -r $dst"
//        val fullCmd = "$copyCmd && $installCmd"
//
//        Log.d("ApkUpdateMgr", "Running root install via: su -c $fullCmd")
//
//        try {
//            val process = Runtime.getRuntime().exec(arrayOf("su", "-c", fullCmd))
//            val stdout = process.inputStream.bufferedReader().readText()
//            val stderr = process.errorStream.bufferedReader().readText()
//            val exitCode = process.waitFor()
//            Log.d("ApkUpdateMgr", "STDOUT:\n$stdout")
//            Log.e("ApkUpdateMgr", "‚ö†STDERR:\n$stderr")
//            Log.d("ApkUpdateMgr", "Exit code: $exitCode")
//
//            // d·ªçn tmp sau c√†i (kh√¥ng b·∫Øt bu·ªôc, nh∆∞ng s·∫°ch)
//            try { Runtime.getRuntime().exec(arrayOf("su", "-c", "rm -f $dst")).waitFor() } catch (_: Exception) {}
//
//            cleanup()
//            onResult(exitCode == 0)
//        } catch (e: Exception) {
//            Log.e("ApkUpdateMgr", "‚ùå installViaRoot failed", e)
//            cleanup()
//            onResult(false)
//        }
//    }

    private fun cleanupTmp(dstQuoted: String) {
        try { runSu("rm -f $dstQuoted") } catch (_: Exception) {}
    }


    private fun installViaIntent(file: File) {
        try {
            val uri = FileProvider.getUriForFile(
                context,
                "${context.packageName}.provider", // ph·∫£i ƒë√∫ng authority trong AndroidManifest
                file
            )

            Log.d("ApkUpdateMgr", "üì¶ Installing via intent using URI: $uri")

            val intent = Intent(Intent.ACTION_VIEW).apply {
                setDataAndType(uri, "application/vnd.android.package-archive")
                flags = Intent.FLAG_ACTIVITY_NEW_TASK or
                        Intent.FLAG_GRANT_READ_URI_PERMISSION
            }

            context.startActivity(intent)


            onResult(true)
        } catch (e: Exception) {
            Log.e("ApkUpdateMgr", "‚ùå installViaIntent failed", e)
            onResult(false)
        }
    }


    private fun cleanup() {
        try {
            context.unregisterReceiver(downloadReceiver)
        } catch (e: Exception) {

        }

        apkFile?.let { file ->
            if (file.exists()) {
                file.delete()
            }
        }
    }

    private fun getApkPackageName(context: android.content.Context, apkFile: java.io.File): String? {
        val pm = context.packageManager
        return try {
            if (android.os.Build.VERSION.SDK_INT >= 33) {
                pm.getPackageArchiveInfo(apkFile.absolutePath,
                    android.content.pm.PackageManager.PackageInfoFlags.of(0))?.packageName
            } else {
                @Suppress("DEPRECATION")
                pm.getPackageArchiveInfo(apkFile.absolutePath, 0)?.packageName
            }
        } catch (_: Exception) { null }
    }

}